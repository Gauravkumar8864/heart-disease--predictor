# -*- coding: utf-8 -*-
"""Heart_Disease.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11rOPZSQPVQSHSzZvCttrzCqpA3W896B5
"""

# core data libs
import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings("ignore")
# plotting
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, StratifiedKFold, cross_validate
from sklearn.preprocessing import MinMaxScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.metrics import RocCurveDisplay
from sklearn.metrics import (accuracy_score, precision_score, recall_score, f1_score,
                             roc_auc_score, confusion_matrix,ConfusionMatrixDisplay, classification_report,
                             average_precision_score)
# models
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import ExtraTreesClassifier, RandomForestClassifier, StackingClassifier, VotingClassifier
from sklearn.preprocessing import OrdinalEncoder
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier

import statsmodels.api as sm
from statsmodels.stats.outliers_influence import variance_inflation_factor

import shap
shap.initjs()

df = pd.read_csv("C:\\Users\\Gaurav\\Downloads\\heart (1).csv")
df.head()

df.info()

df.describe()

df.isnull().sum()

df.duplicated()

df.nunique()

df['Sex']= df['Sex'].map({'F':0, 'M':1})

df['Sex']= df['Sex'].astype(int)
df.info()


df['ChestPainType']= df['ChestPainType'].map({'ATA':0, 'NAP':1, 'ASY':2, 'TA':3})
df['ChestPainType']= df['ChestPainType'].astype(int)

encoder = OrdinalEncoder()
df[["RestingECG", "ChestPainType"]] = encoder.fit_transform(df[["RestingECG", "ChestPainType"]])
df[["ExerciseAngina", "ST_Slope"]] = encoder.fit_transform(df[["ExerciseAngina", "ST_Slope"]])

# df.corr()

# plt.figure(figsize=(10,10))
# sns.heatmap(df.corr(),annot=True)

X=df.drop(columns=['HeartDisease'], axis=1)
y=df['HeartDisease']

df['Age'].mean()

df['Age'].std()

df['Age'].var()

df.describe()

df['Age'].min()

df['Age'].max()

print("\nTarget (HeartDisease) value counts:")
print(df['HeartDisease'].value_counts(normalize=False))
print(df['HeartDisease'].value_counts(normalize=True))

plt.figure(figsize=(10,8))
corr = df.drop(columns=['HeartDisease']).select_dtypes(include=['int64','float64']).corr()
sns.heatmap(corr, annot=True, fmt=".2f", cmap='coolwarm', square=True)
plt.title("Correlation (numeric features)")
plt.show()

X = df.drop(columns=['HeartDisease'])
y = df['HeartDisease']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)
print("train/test sizes:", X_train.shape, X_test.shape)

lr=LogisticRegression()
lr.fit(X_train, y_train)

y_pred=lr.predict(X_test)

feature = 'Age'
plt.scatter(X[feature], y, color='blue', label='Actual')
plt.plot(X[feature], lr.predict(X), color='red', label='Predicted')
plt.xlabel(feature)
plt.ylabel('HeartDisease')
plt.legend()
plt.title('Logistic Regression Prediction vs Actual')
plt.show()

# Confusion Matrix
ConfusionMatrixDisplay.from_estimator(lr, X_test, y_test)
plt.title("Confusion Matrix")
plt.show()

# ROC Curve
RocCurveDisplay.from_estimator(lr, X_test, y_test)
plt.title("ROC Curve")
plt.show()

plt.scatter(X[feature], y, color='blue', label='Actual')
plt.plot(X[feature], lr.predict(X), color='red', label='Predicted Probability')
plt.axhline(0.5, color='green', linestyle='--', label='Decision Threshold (0.5)')
plt.xlabel('Age')
plt.ylabel('HeartDisease')
plt.legend()
plt.title('Logistic Regression with Decision Threshold')
plt.show()

import shap
shap.initjs()

# Pipelines
numeric_features = ['Age','RestingBP','Cholesterol','FastingBS','MaxHR','Oldpeak']
categorical_features = ['Sex','ChestPainType','RestingECG','ExerciseAngina','ST_Slope']

numeric_transformer = Pipeline([
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', MinMaxScaler())
])
categorical_transformer = Pipeline([
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))
])

preprocessor = ColumnTransformer([
    ('num', numeric_transformer, numeric_features),
    ('cat', categorical_transformer, categorical_features)
])

# Base models
et = ExtraTreesClassifier(n_estimators=100, random_state=42)
rf = RandomForestClassifier(n_estimators=100, random_state=42)
cb = CatBoostClassifier(iterations=500, learning_rate=0.03, verbose=0, random_state=42)
xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss', n_estimators=200, random_state=42)
lgbm = LGBMClassifier(n_estimators=200, random_state=42)
lr = LogisticRegression(max_iter=1000, random_state=42)

# Stacking
stacking_clf = Pipeline([
    ('preproc', preprocessor),
    ('stack', StackingClassifier(
        estimators=[('et', et), ('rf', rf), ('cb', cb), ('xgb', xgb), ('lgbm', lgbm)],
        final_estimator=LogisticRegression(max_iter=1000),
        cv=5,
        n_jobs=-1
    ))
])

stacking_clf.fit(X_train, y_train)

y_pred = stacking_clf.predict(X_test)
y_prob = stacking_clf.predict_proba(X_test)[:,1]

print("Accuracy:", accuracy_score(y_test, y_pred))
print("Precision:", precision_score(y_test, y_pred))
print("Recall:", recall_score(y_test, y_pred))
print("F1 Score:", f1_score(y_test, y_pred))
print("ROC AUC:", roc_auc_score(y_test, y_prob))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# new_patient = pd.DataFrame([{
#     'Age': 120,
#     'Sex': 'M',
#     'ChestPainType': 'ASY',
#     'RestingBP': 540,
#     'Cholesterol': 520,
#     'FastingBS': 0,
#     'RestingECG': 'ST',
#     'MaxHR': 300,
#     'ExerciseAngina': 'Y',
#     'Oldpeak': 1.2,
#     'ST_Slope': 'Flat'
# }], columns=X.columns)   # <--- important

# # Predict
# prediction = stacking_clf.predict(new_patient)[0]
# probability = stacking_clf.predict_proba(new_patient)[0][1]

# print("Prediction:", prediction)
# print("Probability:", probability)

import joblib

# Save trained stacking model
joblib.dump(stacking_clf, "stacking_pipeline.joblib")
print("Model saved as stacking_pipeline.joblib")

import gradio as gr
import joblib

# Load your trained model
model = joblib.load("stacking_pipeline.joblib")

def predict_heart_disease(Age, Sex, ChestPainType, RestingBP, Cholesterol,
                          FastingBS, RestingECG, MaxHR, ExerciseAngina, Oldpeak, ST_Slope):
    new_data = pd.DataFrame([{
        "Age": Age,
        "Sex": Sex,
        "ChestPainType": ChestPainType,
        "RestingBP": RestingBP,
        "Cholesterol": Cholesterol,
        "FastingBS": FastingBS,
        "RestingECG": RestingECG,
        "MaxHR": MaxHR,
        "ExerciseAngina": ExerciseAngina,
        "Oldpeak": Oldpeak,
        "ST_Slope": ST_Slope
    }])
    pred = model.predict(new_data)[0]
    prob = model.predict_proba(new_data)[0][1]
    return f"Prediction: {'Heart Disease' if pred==1 else 'No Heart Disease'} (prob={prob:.2f})"

# Gradio UI
demo = gr.Interface(
    fn=predict_heart_disease,
    inputs=[
        gr.Number(label="Age"),
        gr.Radio(["M","F"], label="Sex"),
        gr.Radio(["ATA","NAP","ASY","TA"], label="Chest Pain Type"),
        gr.Number(label="Resting BP"),
        gr.Number(label="Cholesterol"),
        gr.Radio([0,1], label="Fasting BS"),
        gr.Radio(["Normal","ST","LVH"], label="Resting ECG"),
        gr.Number(label="Max HR"),
        gr.Radio(["Y","N"], label="Exercise Angina"),
        gr.Number(label="Oldpeak"),
        gr.Radio(["Up","Flat","Down"], label="ST Slope")
    ],
    outputs="text"
)

demo.launch()


